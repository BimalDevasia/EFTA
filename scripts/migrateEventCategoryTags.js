/**
 * Database Migration Script: Auto-generate category tags from titles
 * 
 * This script updates all existing event categories to have auto-generated tags
 * based on their titles (lowercase, no spaces, URL-friendly format).
 * 
 * Run this script once after updating the admin interface.
 */

const mongoose = require('mongoose');
require('dotenv').config();

// MongoDB connection
const MONGODB_URI = process.env.MONGODB_URI;

if (!MONGODB_URI) {
  throw new Error('Please define the MONGODB_URI environment variable inside .env');
}

async function connectDB() {
  try {
    if (mongoose.connection.readyState >= 1) {
      return;
    }
    
    await mongoose.connect(MONGODB_URI);
    console.log('‚úÖ Connected to MongoDB');
  } catch (error) {
    console.error('‚ùå MongoDB connection error:', error);
    throw error;
  }
}

// Event Category Schema
const eventCategorySchema = new mongoose.Schema({
  title: {
    type: String,
    required: [true, 'Event category title is required'],
    trim: true
  },
  tag: {
    type: String,
    required: [true, 'Event category tag is required'],
    trim: true,
    lowercase: true,
    unique: true
  },
  color: {
    type: String,
    required: [true, 'Color is required'],
    enum: ['#FB7D76', '#F06995', '#DB53AA', '#9B59B6', '#E74C3C', '#3498DB', '#2ECC71', '#F39C12', '#E67E22', '#95A5A6'],
    default: '#FB7D76'
  },
  emoji: {
    type: String,
    default: '',
    trim: true
  },
  icon: {
    type: String,
    default: '',
    trim: true
  },
  products: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Product'
  }],
  isActive: {
    type: Boolean,
    default: true
  }
}, {
  timestamps: true
});

const EventCategory = mongoose.models.EventCategory || mongoose.model('EventCategory', eventCategorySchema);

// Function to generate URL-friendly tag from title
function generateTagFromTitle(title) {
  return title
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, '') // Remove special characters
    .replace(/\s+/g, '-') // Replace spaces with hyphens
    .replace(/-+/g, '-') // Replace multiple hyphens with single hyphen
    .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens
}

async function migrateEventCategoryTags() {
  try {
    console.log('üöÄ Starting Event Category Tag Migration...');
    
    // Connect to database
    await connectDB();
    console.log('‚úÖ Connected to database');
    
    // Get all event categories
    const categories = await EventCategory.find({});
    console.log(`üìä Found ${categories.length} categories to process`);
    
    if (categories.length === 0) {
      console.log('‚ÑπÔ∏è No categories found to migrate');
      return;
    }
    
    let updateCount = 0;
    let skipCount = 0;
    const duplicateChecks = new Map();
    
    for (const category of categories) {
      const currentTag = category.tag;
      const autoGeneratedTag = generateTagFromTitle(category.title);
      
      console.log(`\nüìù Processing: "${category.title}"`);
      console.log(`   Current tag: "${currentTag}"`);
      console.log(`   Generated tag: "${autoGeneratedTag}"`);
      
      // Check if tag needs updating
      if (currentTag === autoGeneratedTag) {
        console.log(`   ‚è≠Ô∏è Skipping - tag already matches generated format`);
        skipCount++;
        continue;
      }
      
      // Check for potential duplicates
      if (duplicateChecks.has(autoGeneratedTag)) {
        console.log(`   ‚ö†Ô∏è Warning: Duplicate tag "${autoGeneratedTag}" detected`);
        console.log(`   Previous category: "${duplicateChecks.get(autoGeneratedTag)}"`);
        console.log(`   Current category: "${category.title}"`);
        
        // Handle duplicate by appending a number
        let uniqueTag = autoGeneratedTag;
        let counter = 2;
        
        while (duplicateChecks.has(uniqueTag) || await EventCategory.findOne({ tag: uniqueTag, _id: { $ne: category._id } })) {
          uniqueTag = `${autoGeneratedTag}-${counter}`;
          counter++;
        }
        
        console.log(`   üîß Using unique tag: "${uniqueTag}"`);
        duplicateChecks.set(uniqueTag, category.title);
        
        // Update category with unique tag
        await EventCategory.findByIdAndUpdate(category._id, { tag: uniqueTag });
        console.log(`   ‚úÖ Updated with unique tag`);
        updateCount++;
      } else {
        // Check if generated tag already exists in database
        const existingCategory = await EventCategory.findOne({ 
          tag: autoGeneratedTag, 
          _id: { $ne: category._id } 
        });
        
        if (existingCategory) {
          console.log(`   ‚ö†Ô∏è Tag "${autoGeneratedTag}" already exists for category: "${existingCategory.title}"`);
          
          // Handle duplicate by appending a number
          let uniqueTag = autoGeneratedTag;
          let counter = 2;
          
          while (await EventCategory.findOne({ tag: uniqueTag, _id: { $ne: category._id } })) {
            uniqueTag = `${autoGeneratedTag}-${counter}`;
            counter++;
          }
          
          console.log(`   üîß Using unique tag: "${uniqueTag}"`);
          duplicateChecks.set(uniqueTag, category.title);
          
          // Update category with unique tag
          await EventCategory.findByIdAndUpdate(category._id, { tag: uniqueTag });
          console.log(`   ‚úÖ Updated with unique tag`);
          updateCount++;
        } else {
          // Tag is unique, proceed with update
          duplicateChecks.set(autoGeneratedTag, category.title);
          
          // Update category
          await EventCategory.findByIdAndUpdate(category._id, { tag: autoGeneratedTag });
          console.log(`   ‚úÖ Updated successfully`);
          updateCount++;
        }
      }
    }
    
    console.log('\nüéâ Migration completed successfully!');
    console.log(`üìä Summary:`);
    console.log(`   - Total categories: ${categories.length}`);
    console.log(`   - Updated: ${updateCount}`);
    console.log(`   - Skipped (already correct): ${skipCount}`);
    
    // Verify migration
    console.log('\nüîç Verifying migration...');
    const updatedCategories = await EventCategory.find({});
    const allTagsValid = updatedCategories.every(cat => {
      const expectedTag = generateTagFromTitle(cat.title);
      const isValid = cat.tag === expectedTag || cat.tag.startsWith(expectedTag + '-');
      if (!isValid) {
        console.log(`‚ùå Invalid tag found: "${cat.tag}" for "${cat.title}"`);
      }
      return isValid;
    });
    
    if (allTagsValid) {
      console.log('‚úÖ All tags are now in correct format');
    } else {
      console.log('‚ùå Some tags still need attention');
    }
    
    // Close database connection
    await mongoose.connection.close();
    console.log('‚úÖ Database connection closed');
    
  } catch (error) {
    console.error('üí• Migration failed:', error);
    throw error;
  }
}

// Run migration
migrateEventCategoryTags()
  .then(() => {
    console.log('‚ú® Migration script completed');
    process.exit(0);
  })
  .catch((error) => {
    console.error('‚ùå Migration script failed:', error);
    process.exit(1);
  });

module.exports = { migrateEventCategoryTags, generateTagFromTitle };
